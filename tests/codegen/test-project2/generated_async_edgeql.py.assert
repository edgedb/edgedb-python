# AUTOGENERATED FROM:
#     'scalar/custom_vector_input.edgeql'
#     'object/link_prop.edgeql'
#     'parpkg/subpkg/my_query.edgeql'
#     'argnames/query_one.edgeql'
#     'parpkg/select_args.edgeql'
#     'object/select_object.edgeql'
#     'object/select_objects.edgeql'
#     'scalar/select_scalar.edgeql'
#     'scalar/select_scalars.edgeql'
# WITH:
#     $ gel-py --target async --file --no-skip-pydantic-validation


from __future__ import annotations
import array
import dataclasses
import datetime
import enum
import gel
import typing
import uuid


MyScalar = int
V3 = typing.Sequence[float]


@dataclasses.dataclass
class LinkPropResult:
    id: uuid.UUID
    name: str
    friends: list[LinkPropResultFriendsItem]


@dataclasses.dataclass
class LinkPropResultFriendsItem:
    id: uuid.UUID
    name: str
    created_at: datetime.datetime | None

    @typing.overload
    def __getitem__(self, key: typing.Literal["@created_at"]) -> datetime.datetime | None:
        ...

    @typing.overload
    def __getitem__(self, key: typing.Literal["@strength"]) -> float | None:
        ...

    def __getitem__(self, key: str) -> typing.Any:
        raise NotImplementedError


class MyEnum(enum.Enum):
    THIS = "This"
    THAT = "That"
    E_1 = "1"
    F_B = "f. b"
    F_B_1 = "f-b"


@dataclasses.dataclass
class MyQueryResult:
    a: uuid.UUID
    b: uuid.UUID | None
    c: str
    d: str | None
    e: bytes
    f: bytes | None
    g: int
    h: int | None
    i: int
    j: int | None
    k: int
    l: int | None
    m: float
    n: float | None
    o: float
    p: float | None
    q: bool
    r: bool | None
    s: datetime.datetime
    t: datetime.datetime | None
    u: datetime.datetime
    v: datetime.datetime | None
    w: datetime.date
    x: datetime.date | None
    y: datetime.time
    z: datetime.time | None
    aa: datetime.timedelta
    ab: datetime.timedelta | None
    ac: int
    ad: int | None
    ae: gel.RelativeDuration
    af: gel.RelativeDuration | None
    ag: gel.DateDuration
    ah: gel.DateDuration | None
    ai: gel.ConfigMemory
    aj: gel.ConfigMemory | None
    ak: gel.Range[int]
    al: gel.Range[int] | None
    am: gel.Range[int]
    an: gel.Range[int] | None
    ao: gel.Range[float]
    ap: gel.Range[float] | None
    aq: gel.Range[float]
    ar: gel.Range[float] | None
    as_: gel.Range[datetime.datetime]
    at: gel.Range[datetime.datetime] | None
    au: gel.Range[datetime.datetime]
    av: gel.Range[datetime.datetime] | None
    aw: gel.Range[datetime.date]
    ax: gel.Range[datetime.date] | None
    ay: MyScalar
    az: MyScalar | None
    ba: MyEnum
    bb: MyEnum | None
    bc: array.array
    bd: array.array | None


@dataclasses.dataclass
class SelectArgsResult:
    Str: str
    DateTime: datetime.datetime


@dataclasses.dataclass
class SelectObjectResult:
    id: uuid.UUID
    Name: str
    Language: str
    Params: list[SelectObjectResultParamsItem]


@dataclasses.dataclass
class SelectObjectResultParamsItem:
    id: uuid.UUID
    Name: str
    Default: str | None


async def custom_vector_input(
    executor: gel.AsyncIOExecutor,
    *,
    input: V3 | None = None,
) -> int | None:
    return await executor.query_single(
        """\
        select 42 filter exists <optional v3>$input;\
        """,
        input=input,
    )


async def link_prop(
    executor: gel.AsyncIOExecutor,
) -> list[LinkPropResult]:
    return await executor.query(
        """\
        create type Person {
            create required property name -> str;
            create property created_at -> datetime;
            create multi link friends -> Person {
                create property strength -> float64;
                create property created_at -> datetime;
            }
        };

        select Person {
            name,
            friends: {
                name,
                @created_at,
                created_at,
                @strength,
            }
        };\
        """,
    )


async def my_query(
    executor: gel.AsyncIOExecutor,
    *,
    a: uuid.UUID,
    b: uuid.UUID | None = None,
    c: str,
    d: str | None = None,
    e: bytes,
    f: bytes | None = None,
    g: int,
    h: int | None = None,
    i: int,
    j: int | None = None,
    k: int,
    l: int | None = None,
    m: float,
    n: float | None = None,
    o: float,
    p: float | None = None,
    q: bool,
    r: bool | None = None,
    s: datetime.datetime,
    t: datetime.datetime | None = None,
    u: datetime.datetime,
    v: datetime.datetime | None = None,
    w: datetime.date,
    x: datetime.date | None = None,
    y: datetime.time,
    z: datetime.time | None = None,
    aa: datetime.timedelta,
    ab: datetime.timedelta | None = None,
    ac: int,
    ad: int | None = None,
    ae: gel.RelativeDuration,
    af: gel.RelativeDuration | None = None,
    ag: gel.DateDuration,
    ah: gel.DateDuration | None = None,
    ai: gel.ConfigMemory,
    aj: gel.ConfigMemory | None = None,
    ak: gel.Range[int],
    al: gel.Range[int] | None = None,
    am: gel.Range[int],
    an: gel.Range[int] | None = None,
    ao: gel.Range[float],
    ap: gel.Range[float] | None = None,
    aq: gel.Range[float],
    ar: gel.Range[float] | None = None,
    as_: gel.Range[datetime.datetime],
    at: gel.Range[datetime.datetime] | None = None,
    au: gel.Range[datetime.datetime],
    av: gel.Range[datetime.datetime] | None = None,
    aw: gel.Range[datetime.date],
    ax: gel.Range[datetime.date] | None = None,
    bc: typing.Sequence[float],
    bd: typing.Sequence[float] | None = None,
) -> MyQueryResult:
    return await executor.query_single(
        """\
        create scalar type MyScalar extending int64;
        create scalar type MyEnum extending enum<'This', 'That', '1', 'f. b', 'f-b'>;

        select {
        	a := <uuid>$a,
        	b := <optional uuid>$b,
        	c := <str>$c,
        	d := <optional str>$d,
        	e := <bytes>$e,
        	f := <optional bytes>$f,
        	g := <int16>$g,
        	h := <optional int16>$h,
        	i := <int32>$i,
        	j := <optional int32>$j,
        	k := <int64>$k,
        	l := <optional int64>$l,
        	m := <float32>$m,
        	n := <optional float32>$n,
        	o := <float64>$o,
        	p := <optional float64>$p,
        	q := <bool>$q,
        	r := <optional bool>$r,
        	s := <datetime>$s,
        	t := <optional datetime>$t,
        	u := <cal::local_datetime>$u,
        	v := <optional cal::local_datetime>$v,
        	w := <cal::local_date>$w,
        	x := <optional cal::local_date>$x,
        	y := <cal::local_time>$y,
        	z := <optional cal::local_time>$z,
        	aa := <duration>$aa,
        	ab := <optional duration>$ab,
        	ac := <bigint>$ac,
        	ad := <optional bigint>$ad,
        	ae := <cal::relative_duration>$ae,
        	af := <optional cal::relative_duration>$af,
        	ag := <cal::date_duration>$ag,
        	ah := <optional cal::date_duration>$ah,
        	ai := <cfg::memory>$ai,
        	aj := <optional cfg::memory>$aj,
        	ak := <range<int32>>$ak,
        	al := <optional range<int32>>$al,
        	am := <range<int64>>$am,
        	an := <optional range<int64>>$an,
        	ao := <range<float32>>$ao,
        	ap := <optional range<float32>>$ap,
        	aq := <range<float64>>$aq,
        	ar := <optional range<float64>>$ar,
        	as_ := <range<datetime>>$as_,
        	at := <optional range<datetime>>$at,
        	au := <range<cal::local_datetime>>$au,
        	av := <optional range<cal::local_datetime>>$av,
        	aw := <range<cal::local_date>>$aw,
        	ax := <optional range<cal::local_date>>$ax,
        	ay := <MyScalar>1,
        	az := <optional MyScalar>{},
        	ba := MyEnum.This,
        	bb := <optional MyEnum>{},
        	bc := <ext::pgvector::vector>$bc,
        	bd := <optional ext::pgvector::vector>$bd,
        }\
        """,
        a=a,
        b=b,
        c=c,
        d=d,
        e=e,
        f=f,
        g=g,
        h=h,
        i=i,
        j=j,
        k=k,
        l=l,
        m=m,
        n=n,
        o=o,
        p=p,
        q=q,
        r=r,
        s=s,
        t=t,
        u=u,
        v=v,
        w=w,
        x=x,
        y=y,
        z=z,
        aa=aa,
        ab=ab,
        ac=ac,
        ad=ad,
        ae=ae,
        af=af,
        ag=ag,
        ah=ah,
        ai=ai,
        aj=aj,
        ak=ak,
        al=al,
        am=am,
        an=an,
        ao=ao,
        ap=ap,
        aq=aq,
        ar=ar,
        as_=as_,
        at=at,
        au=au,
        av=av,
        aw=aw,
        ax=ax,
        bc=bc,
        bd=bd,
    )


async def query_one(
    executor: gel.AsyncIOExecutor,
    *,
    arg_name_with_underscores: int,
) -> int:
    return await executor.query_single(
        """\
        select <int64>$arg_name_with_underscores\
        """,
        arg_name_with_underscores=arg_name_with_underscores,
    )


async def select_args(
    executor: gel.AsyncIOExecutor,
    *,
    arg_str: str,
    arg_datetime: datetime.datetime,
) -> SelectArgsResult:
    return await executor.query_single(
        """\
        select {
        	Str := <str>$arg_str,
        	DateTime := <datetime>$arg_datetime,
        }\
        """,
        arg_str=arg_str,
        arg_datetime=arg_datetime,
    )


async def select_object(
    executor: gel.AsyncIOExecutor,
) -> SelectObjectResult | None:
    return await executor.query_single(
        """\
        select schema::Function {
          Name := .name,
          Language := .language,
          Params := .params {
            Name := .name,
            Default := .default,
          }
        }
        limit 1;\
        """,
    )


async def select_objects(
    executor: gel.AsyncIOExecutor,
) -> list[SelectObjectResult]:
    return await executor.query(
        """\
        select schema::Function {
          Name := .name,
          Language := .language,
          Params := .params {
            Name := .name,
            Default := .default,
          }
        }\
        """,
    )


async def select_scalar(
    executor: gel.AsyncIOExecutor,
) -> int:
    return await executor.query_single(
        """\
        select 1;\
        """,
    )


async def select_scalars(
    executor: gel.AsyncIOExecutor,
) -> list[gel.ConfigMemory]:
    return await executor.query(
        """\
        select <cfg::memory>{1, 2, 3};\
        """,
    )
